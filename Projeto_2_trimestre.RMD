---
title: "Projeto"
author: "Diego,Raul,Thais"
date: "18/06/2022"
output: html_document
---


```{r GlobalOptions}
options(knitr.duplicate.label = 'allow')
```

#Contextualização

##O conjunto de dados mostra informações sobre os hábitos de compra do cliente. O objetivo da análise é investigar a segmentação de clientes bem como predizer o volume de gasto médio do consumidor, a fim de permitir que a empresa compreenda as diferentes categorias de clientes que possui e predizer o volume médio de receita. O conjunto de dados contém as seguintes informações sobre cada cliente:

##ID: identificador exclusivo do cliente
##Year_Birth: Ano de nascimento do cliente
##Education: nível de educação do cliente
##Marital_Status: estado civil do cliente
##Income: Renda familiar anual do cliente
##Kidhome: Número de crianças na casa do cliente
##Teenhome: Número de adolescentes na casa do cliente
##Dt_Customer: Data do cadastro do cliente na empresa
##Recency: número de dias desde a última compra do cliente
##Complain: 1 se o cliente reclamou nos últimos 2 anos, 0 caso contrário
##MntWines: Valor gasto em vinho nos últimos 2 anos
##MntFruits: Valor gasto em frutas nos últimos 2 anos
##MntMeatProducts: Valor gasto em carne nos últimos 2 anos
##MntFishProducts: Valor gasto em pescado nos últimos 2 anos
##MntSweetProducts: Valor gasto em doces nos últimos 2 anos
##MntGoldProds: Valor gasto em ouro nos últimos 2 anos
##NumDealsPurchases: Número de compras feitas com desconto
##AcceptedCmp1: 1 se o cliente aceitou a oferta na 1ª campanha, 0 caso contrário
##AcceptedCmp2: 1 se o cliente aceitou a oferta na 2ª campanha, 0 caso contrário
##AcceptedCmp3: 1 se o cliente aceitou a oferta na 3ª campanha, 0 caso contrário
##AcceptedCmp4: 1 se o cliente aceitou a oferta na 4ª campanha, 0 caso contrário
##AcceptedCmp5: 1 se o cliente aceitou a oferta na 5ª campanha, 0 caso contrário
##Response: 1 se o cliente aceitou a oferta na última campanha, 0 caso contrário
##NumWebPurchases: Número de compras feitas através do site da empresa
##NumCatalogPurchases: Número de compras feitas usando um catálogo
##NumStorePurchases: Número de compras feitas diretamente nas lojas
##NumWebVisitsMonth: Número de visitas ao site da empresa no último mês

#Preparação

```{r GlobalOptions, include=FALSE}

#Pacotes Utilizados

library(tidyverse)
library(janitor)
library(skimr)
library(lubridate)
library(plotly)
library(factoextra)
library(ggrepel)
library(cluster)
library(fpc)
library(dbscan)
library(tidymodels)
library(vip)
library(ggcorrplot)

```

#Visualização dos dados

```{r GlobalOptions, include=FALSE}

df<-read.csv("marketing_campaign.csv",sep = "\t") %>% 
  clean_names() # standardarização dos nomes das colunas

```

#Alteração dos nomes das colunas

```{r GlobalOptions, include=FALSE}

#Verificação dos nomes das colunas:

colnames(df)

#Alteração dos nomes das colunas

df<-df %>% 
  rename(cust_retention_year=dt_customer,
         days_wo_purchase=recency,
         wine=mnt_wines,
         fruit=mnt_fruits,
         meat=mnt_meat_products,
         fish=mnt_fish_products,
         sweet=mnt_sweet_products,
         gold=mnt_gold_prods,
         deals_purchases=num_deals_purchases,
         web_purchases=num_web_purchases,
         catalog_purchases=num_catalog_purchases,
         store_purchases=num_store_purchases,
         web_visits_month=num_web_visits_month
  )

```

#Verificação dos tipos de dados

```{r GlobalOptions, include=FALSE}

skim(df)

#Ajuste dos tipos de dados

df$accepted_cmp1<- factor(df$accepted_cmp1)
df$accepted_cmp2<- as.factor(df$accepted_cmp2)
df$accepted_cmp3<- as.factor(df$accepted_cmp3)
df$accepted_cmp4<- as.factor(df$accepted_cmp4)
df$accepted_cmp5<- as.factor(df$accepted_cmp5)
df$complain<- as.factor(df$complain)

```

#Como só temos um output (único valor) em algumas colunas, iremos removê-las da base por não agregarem valor a nossa análise

```{r GlobalOptions, include=FALSE}
#Output das colunas bem como a quantidade de cada opção

table(df['z_revenue'],useNA='always')
table(df['z_cost_contact'],useNA='always')

df['z_cost_contact'] <-NULL
df['z_revenue']<- NULL

```

#Inclusão de novas colunas baseadas nas variáveis que possuímos:

```{r GlobalOptions, include=FALSE}

# Idade dos consumidores:
df['age']<- 2014 - df['year_birth'] 
#importante comentar que utilizamos 2014 nesse cálculo, pois a base de dados utilizada foi desse ano

#Número de filhos:
df['children']<- df['kidhome']+df['teenhome'] 

#Número de anos no qual cliente é consumidor dessa empresa:
df['cust_retention_year']<- 2014 - as.integer(str_sub(df$cust_retention_year,-4)) 

# Se o consumidor é casado:
df['married'] <- 
  ifelse(df['marital_status']=='Alone'|df['marital_status']=='Single'|df['marital_status']=='Divorced'|df['marital_status']=='Widow',0,
  (ifelse(df['marital_status']=='Married'|df['marital_status']=='Together',1,NA)))

# Se consumidor é casado (categórico):
df['marital_status'] <- 
  ifelse(df['marital_status']=='Alone'|df['marital_status']=='Single'|df['marital_status']=='Divorced'|df['marital_status']=='Widow','Single',
  (ifelse(df['marital_status']=='Married'|df['marital_status']=='Together','Married',NA)))

#Total de gastos:
df['total_expense'] <- df['wine']+df['fruit']+df['meat']+df['fish']+df['sweet']+df['gold']

#Classe Social:
df['social_class'] <- ifelse(df['income']<=32000,'Class E',
                      (ifelse(df['income']>32000 & df['income']<=53000,'Class D',
                      (ifelse(df['income']>53000 & df['income']<=107000,'Class C',        
                      (ifelse(df['income']>107000 & df['income']<=37400,'Class B','Class A')))))))
             
#Intervalo de Idade:
df['age_class'] <-ifelse(df['age']<=30,'<=30',
                  (ifelse(df['age']>30 & df['age']<=50,'30-50',
                  (ifelse(df['age']>50 & df['age']<=70,'50-70','>70')))))

#Número de Compras:

df['total_purchases']<- df['web_purchases']+df['catalog_purchases']+df['store_purchases']

#Porcentagem de Compras Online:

df['online_purchases']<-df['web_purchases']/df['total_purchases']

#Número de anos estudando

df['years_education']<-ifelse(df['education']=='	
2n Cycle',8,
            (ifelse(df['education']=='Basic',12,
            (ifelse(df['education']=='Graduation',16,                   (ifelse(df['education']=='Master',18,22)))))))

# Formação:
df['education_2'] <- 
  ifelse(df['education']=='2n Cycle'|df['education']=='Basic','Not gratuated',
  (ifelse(df['education']=='Graduation'|df['education']=='Master'|df['education']=='PhD','Gratuated',NA)))

#Volume de compras com desconto

df['purchase_discount']<-df$deals_purchase/df$total_purchases

#O valor da coluna acima, purchase_discount, necessariamente precisa estar num intervalo entre 0 e 1, portanto removeremos os demais casos que não se encontram nesse cenário,pois pode ter ocorrido por conta de alguma inconsistência na base

df<-df %>% 
  filter(purchase_discount<=1)

#Volume de compras com desconto (categórico)

df['purchase_discount2'] <- ifelse(df['purchase_discount']<=0.25,'0-25%',
                      (ifelse(df['purchase_discount']>0.25 & df['purchase_discount']<=0.5,'25%-50%',
                      (ifelse(df['purchase_discount']>0.5 & df['purchase_discount']<=0.75,'50%-75%','75%-100%')))))

#Gasto Médio por compra 

df['avg_purchase']<-df$total_expense/df$total_purchases

```

#A adição de novas variáveis nos auxiliará tanto nas análises de segmentação do cliente bem como na predição, pois poderemos utilizar variáveis contínuas adicionais no PCA e K-means, e variáveis categóricas na modelagem

#Remoção de NAs da base

```{r GlobalOptions, include=FALSE}

#Como o número de NAs é baixo, iremos removê-lo da nossa base

df<-drop_na(df)

#Por conta dessa remoção, removemos cerca de 1,5% de observações da base total

```

#Análise detalhada da base

#Antes de iniciarmos a análise da base em si através de modelos estatísticos, verificaremos em maiores detalhes as informações disponíveis:

# Distribuição de idade

```{r GlobalOptions, include=FALSE}

# Distribuição de idade
age<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=age), binwidth=10) +
    geom_vline(aes(xintercept=mean(age)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(age)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - idade dos consumidores')
age

#A mediana e a média estão bem próximas, parece que a média está tendendo à localização central do intervalo de idades, portanto parece que o dataset tem uma distribuição simétrica.

#Porém temos alguns valores extremos acima de 100 anos que podem acabar impactando nas análises posteriores, então como se trata de somente 3 casos,as retiraremos, isso não impactará no volume de dados que teremos para análise

```

# Filtro de idade

```{r GlobalOptions, include=FALSE}

df<-df %>% 
  filter(age<=100)
```

# Distribuição de Escolaridade 

```{r GlobalOptions, include=FALSE}

# Distribuição de Escolaridade 
educ<-ggplot(data=df, aes(education,fill=education)) +
    geom_bar(aes(y=(..count..)/sum(..count..))) + 
    scale_y_continuous(labels = scales::percent)+
    ylab("frequencia relativa")+
    ggtitle('Histograma - Nivel de Educacao')

educ

#A maioria dos consumidores parece ter graduação superior, cerca de 90%.

```

#Distribuição Status Civil

```{r GlobalOptions, include=FALSE}

# Distribuição Status Civil
marital<-ggplot(data=df, aes(marital_status,fill=marital_status)) +
    geom_bar(aes(y=(..count..)/sum(..count..))) + 
    scale_y_continuous(labels = scales::percent)+
    ylab("frequencia relativa")+
    ggtitle('Histograma - Status Civil')

marital

#A distribuição entre as opções de status civil é similar, tendo uma porcentagem um pouco maior de pessoas casadas presentes na base (cerca de 60%)

```

#Distribuição de Renda

```{r GlobalOptions, include=FALSE}

#Distribuição de Renda
income<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=income),bins=15) +
    geom_vline(aes(xintercept=mean(income)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(income)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - Renda dos consumidores')

income

#Pode-se observar que temos alguns valores discrepantes na renda (rendas superiores a 200k),e isso pode acabar impactando nas nossas análises posteriores no PCA e K-means, pois são sensíveis à presença de outliers, então para melhorarmos nossa análise,retiraremos esses casos utilizando o Método de intervalo interquartil.

df<-df %>% 
  filter(income<=500000)

```

#Método de intervalo interquartil

```{r GlobalOptions, include=FALSE}

df %>% 
  count(income>200000) 

Q1 <- quantile(df$income, .25)
Q3 <- quantile(df$income, .75)
IQR <- IQR(df$income)

no_outliers <- subset(df, df$income > (Q1 - 1.5*IQR) & df$income < (Q3 + 1.5*IQR))
dim(no_outliers)

#Como temos 40 observações consideradas outliers nesse caso, iremos removê-las por se tratar de um volume baixo

```

#Distribuição do número de filhos

```{r GlobalOptions, include=FALSE}

#Distribuição do número de filhos
children<-ggplot(data=df, aes(children,fill=children)) +
    geom_bar(aes(y=(..count..)/sum(..count..))) + 
    scale_y_continuous(labels = scales::percent)+
    ylab("frequencia relativa")+
    ggtitle('Histograma - Número de filhos')

children

#A maioria dos consumidores possui filhos, cerca de 70% possui ao menos um filho.

```

#Distribuição do volume de compras médio

```{r GlobalOptions, include=FALSE}

# Distribuição do volume de compras médio

avg_purchase<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=avg_purchase),bins=5) +
    geom_vline(aes(xintercept=mean(avg_purchase)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(avg_purchase)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - Renda dos consumidores')

avg_purchase

#Gasto médio de compras é baixo, cerca de 40 dólares, pode-se supor que isso pode estar ocorrendo por dois motivos:
#Perfil de cliente: cliente pode estar realizando compras em valores mais baixos, só que mais recorrentes
#Perfil do mercado: mercado pode estar sendo utilizado para compras menores 

```

#Distribuição da proporção de compras com desconto

```{r GlobalOptions, include=FALSE}

#Distribuição da proporção de compras com desconto
purchase_disc<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=purchase_discount),bins=5) +
    geom_vline(aes(xintercept=mean(purchase_discount)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(purchase_discount)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - Proporção de compras com desconto')

purchase_disc

#Pode-se observar que em média 20% a 25% das compras são realizadas com desconto, portanto, pode ser que o cliente alvo desse mercado tenha como um forte direcionador o preço.

```

#Distribuição de retenção em anos de clientes

```{r GlobalOptions, include=FALSE}

#Distribuição de retenção em anos de clientes
retention<-ggplot(data=df, aes(cust_retention_year,fill=cust_retention_year)) +
    geom_bar(aes(y=(..count..)/sum(..count..))) + 
    scale_y_continuous(labels = scales::percent)+
    ylab("frequencia relativa")+
    ggtitle('Histograma - Retenção de cliente (em anos)')

retention

#A maioria dos consumidores são clientes há pelo menos um ano.

```

#Distribuição de dias sem compra

```{r GlobalOptions, include=FALSE}

#Distribuição de dias sem compra
days_wo<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=days_wo_purchase),bins=5) +
    geom_vline(aes(xintercept=mean(days_wo_purchase)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(days_wo_purchase)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - Dias sem cliente realizar compra')

days_wo

#Parece ser bem variado, temos um volume similar de clientes sem realizar compras até 45 dias e acima desse intervalo também.

```

#Distribuição da proporção de compras realizadas online

```{r GlobalOptions, include=FALSE}

#Distribuição da proporção de compras realizadas online
online<-ggplot(data=df) +
    geom_histogram(mapping=aes(x=online_purchases),bins=5) +
    geom_vline(aes(xintercept=mean(online_purchases)), linetype='dashed', color='red', size=0.5) +
    geom_vline(aes(xintercept=median(online_purchases)), linetype='dashed', color='red', size=0.5) +
    ggtitle('Histograma - Proporção de compras online')

online

#Pode-se observar que em média 30% das compras são realizadas online, portanto, pode ser que o cliente alvo desse mercado esteja começando a utilizar outros meios de compras.

```

#A partir das informações já conseguimos tirar algums conclusões superficiais, parece que o perfil do cliente em geral são consumidores de 40 a 50 anos que possuem gradução superior, tem ao menos um filho e um renda média de cerca de 50kUSD/ano.

#Antes de aplicarmos o PCA na base de dados, iremos verificar se as variáveis da nossa base estão correlacionadas, caso não estejam, talvez não seja necessária a utilização do PCA:

```{r GlobalOptions, include=FALSE}

# Creating a correlation plot 
df2<-df %>%     
  select(income,kidhome,teenhome,cust_retention_year,days_wo_purchase,wine,fruit,meat,fish,sweet,gold,deals_purchases,web_purchases,catalog_purchases,store_purchases,web_visits_month,age,children,total_expense,total_purchases,years_education,online_purchases,avg_purchase,purchase_discount) 

cormat <- round(cor(df2), 2)

ggcorrplot(cormat, hc.order = TRUE, type ='lower',outline.color ='white',tl.cex = 4,ggtheme = ggplot2::theme_gray,colors = c("#6D9EC1", "white", "#E46726"))

#Pode-se observar que grandes partes dos nossos dados são correlacionados,negativamente (-1) ou positivamente (+1),portanto podemos seguir com o PCA.

```

#PCA

##Seleção de variáveis para análise e aplicação do PCA

```{r GlobalOptions, include=FALSE}

pca<- df %>% 
  select(income,kidhome,teenhome,cust_retention_year,days_wo_purchase,wine,fruit,meat,fish,sweet,gold,deals_purchases,web_purchases,catalog_purchases,store_purchases,web_visits_month,age,children,total_expense,total_purchases,years_education,online_purchases,avg_purchase,purchase_discount) %>% 
  prcomp(scale = TRUE) 

```

##Percentual da variância explicado por cada componente:

```{r GlobalOptions, include=FALSE}

fviz_eig(pca, addlabels = TRUE,
         ncp = 10) + # ncp - número de componentes mostrados
  labs(x='Componente Principal',
       y='Percentual explicado da variância')

#Considerando-se o PC1 e PC2, cerca de 50% da variação é explicado por elas.

```

##Soma acumulado do percentual explicado da variância

```{r GlobalOptions, include=FALSE}

(cumsum(pca$sdev^2)/sum(pca$sdev^2))[1:10]

```

#Matriz de cargas e scores:

```{r GlobalOptions, include=FALSE}

phi<- pca$rotation 
z<- pca$x

```

#Alteração do nome das colunas

```{r GlobalOptions, include=FALSE}
 
colnames(z) <- paste0('driver:_',1:ncol(z))

```

#Interpretação dos drivers:

##PC1

```{r GlobalOptions, include=FALSE}

#Contribuição das variáveis selecionadas no valor gasto pelos consumidores:

pc1 <-pca %>% 
  fviz_contrib(choice = "var",axes = 1,top=8,sort.val = "asc",fill = "steelblue", color="black")+
  labs(title="Impacto das variáveis selecionadas no primeiro driver")+
  coord_flip() #inversão das coordernadas x e y

pc1

#Observando-se as variáveis de maior impacto no PC1, pode-se dizer que o maior driver seria o volume de gastos em compras

```

##PC2

```{r GlobalOptions, include=FALSE}

#Contribuição das variáveis selecionadas no valor gasto pelos consumidores:

pc2<-pca %>% 
  fviz_contrib(choice = "var",axes = 2,top=8,sort.val = "asc",fill = "steelblue", color="black")+
  labs(title="Impacto das variáveis selecionadas no segundo driver")+
  coord_flip() #inversão das coordernadas x e y

pc2

#No PC2, o maior driver seria compras realizadas em promocao

```

##Gráfico de dispersão em função de filhos

```{r GlobalOptions, include=FALSE}

#Gráfico de dispersão em função de filhos
tibble(PC1=z[,1], PC2=z[,2]) %>% 
  ggplot(aes(PC1,PC2,color=df$children))+geom_point()+
  labs(x = "volume de gastos em compras", y = "compras realizadas em promocao",
       title = "Comportamento de consumo")+
  geom_hline(yintercept =0)+
  geom_vline(xintercept =0)

#Parece ter correlação

```
#Os main drivers definidos através do PCA parecem ter correlação com a questão do consumidor ter filhos.Diferente da percepção inicial do time,de acordo com o gráfico,quanto maior a despesa com compras bem como o número de compras realizadas em promoção, menor é o número de filhos do consumidor. Pode ser que isso esteja ocorrendo por conta do tipo de produto comprado, caso os consumidores comprem em maior quantidade bens de consumo básico, independente do valor,a compra é realizado. Porém, consumidores sem filhos, podem estar comprando produtos premium/dispensáveis em promoção.
#Isso pode servir como um noteador para verificar qual deveria ser o cliente alvo nos envios de informações referentes à desconto e o tipo de produto a ser informado.

##Gráfico de dispersão em função do grau de escolaridade

```{r GlobalOptions, include=FALSE}
#gráfico de dispersão em função do grau de escolaridade
tibble(PC1=z[,1], PC2=z[,2]) %>% 
  ggplot(aes(PC1,PC2,color=df$education))+geom_point()+
  labs(x = "volume de gastos em compras", y = "compras realizadas em promocao",
       title = "Comportamento de consumo")+
  geom_hline(yintercept =0)+
  geom_vline(xintercept =0)

#Não parece ter correlação

```

#gráfico de dispersão em função de status civil

```{r GlobalOptions, include=FALSE}
#gráfico de dispersão em função de status civil
tibble(PC1=z[,1], PC2=z[,2]) %>% 
  ggplot(aes(PC1,PC2,color=df$married))+geom_point()+
  labs(x = "volume de gastos em compras", y = "compras realizadas em promocao",
       title = "Comportamento de consumo")+
  geom_hline(yintercept =0)+
  geom_vline(xintercept =0)
#Não parece ter correlação

```

#Gráfico de dispersão em função de classe social

```{r GlobalOptions, include=FALSE}

#gráfico de dispersão em função de classe social
tibble(PC1=z[,1], PC2=z[,2]) %>% 
  ggplot(aes(PC1,PC2,color=df$social_class))+geom_point()+
  labs(x = "volume de gastos em compras", y = "compras realizadas em promocao",
       title = "Comportamento de consumo")+
  geom_hline(yintercept =0)+
  geom_vline(xintercept =0)

#Parece ter correlação

```

##Os main drivers definidos através do PCA parecem ter correlação com a classe econômica do cliente.De acordo com o gráfico,quanto maior a despesa com compras bem como o número de compras realizadas em promoção, maior é o poder aquisitivo do cliente. 
##A classe E, tem um gasto menor de compras que os outros grupos, e realiza em maior frequência compras com desconto. A classe D também possui um gasto menor em compras, porém não é tão suscetível à promoções como o grupo E, isso pode ser um sinal para verificar se as promoções realizadas à esse grupo estão sendo efetivas ou se um ajuste no discurso pode ser necessário.
##E como esperado, a classe C possui o maior valor gastos em compra. 
##Por último, pode-se perceber que os consumidores desse mercado se encontram entre a classe C e E, isso já pode servir como um indicativo de quais são os meios de comunicação mais efetivos para esses grupos. 

#Gráfico de dispersão em função da idade

```{r GlobalOptions, include=FALSE}
#gráfico de dispersão em função da idade

tibble(PC1=z[,1], PC2=z[,2]) %>% 
  ggplot(aes(PC1,PC2,color=df$age_class))+geom_point()+
  labs(x = "volume de gastos em compras", y = "compras realizadas em promocao",
       title = "Comportamento de consumo")+
  geom_hline(yintercept =0)+
  geom_vline(xintercept =0)

#Parece ter certa relação

```

#Parece que consumidores com idade igual ou inferior a 30 anos, realizam mais compras com desconto, independente dos gastos em compr. Já o comportamento dos clientes acima de 30 anos é be heterogêneo, então é difícil tirar conclusões somente a partir dessa informação.

#K means

##Seleção das variáveis a serem utilizadas na análise

```{r GlobalOptions, include=FALSE}
df_k<-df %>% 
  select(income,cust_retention_year,days_wo_purchase,wine,fruit,meat,fish,sweet,gold,web_visits_month,age,children,total_expense,total_purchases,avg_purchase,years_education,online_purchases,purchase_discount) %>% 
  scale()

```

#Análise do número de cluster

```{r GlobalOptions, include=FALSE}

set.seed(42)

tibble(k=2:15) %>% 
  mutate(w = map_dbl(k, ~kmeans(df_k,centers = .x)$tot.withinss)) %>% 
  ggplot(aes(x=k,y=w)) +
  geom_point()+
  geom_line()

# K=3, oberva-se que após esse número, o valor de W começa a diminuir consistentemente.

```

#Realização da análise quantitativa

```{r GlobalOptions, include=FALSE}

descricao<-df %>% 
  mutate(cluster=factor(kmeans(df_k,centers = 3)$cluster))

tab<- descricao %>% 
  select(-id,-year_birth,-marital_status,-kidhome,
         -teenhome,-cust_retention_year,-days_wo_purchase,-web_purchases,-catalog_purchases,-store_purchases,-response) %>% 
  group_by(cluster) %>% 
  summarise(across(where(is.numeric),mean)) 

```

#Baseado na tabela tab que traz a média dos valores de cada variável por cluster,as variáveis nos quais conseguimos verificar diferença seria:
#Income,wine,fruit,meat,fish,sweet,gold,deals of purchase,web_visits_month,children,purchase_discount,avg_purchase
#Já as seguintes variáveis são similares entre os cluster definidos:
#Idade, status civil,online purchases,years_education

#Realização da análise quantitativa - construção de hipóteses

```{r GlobalOptions, include=FALSE}

tab<- tab %>% 
  mutate( p_wine=wine*100/total_expense,
          p_fruit=fruit*100/total_expense,
          p_fish=fish*100/total_expense,
          p_sweet=sweet*100/total_expense,
          p_gold=gold*100/total_expense
  )

tab2 <- tab %>% select(p_wine,p_fruit,p_fish,p_sweet,p_gold)

```

#Realização da análise quantitativa

```{r GlobalOptions, include=FALSE}

tab<-tab %>% 
  select(-wine,-fruit,-fish,meat,-sweet,-gold,-age,-married,-online_purchases,-years_education,-p_wine,-p_fruit,-p_fish,-p_sweet,-p_gold)

tab

```

#Análise gráfica 3d - por cluster - discount

```{r GlobalOptions, include=FALSE}

colors <- c('#4AC6B7', '#1972A4', '#965F8A', '#FF7070')

plot_ly(descricao,x=~avg_purchase,y=~purchase_discount,color=~cluster,colors=colors,size=3)

```
##Observa-se que a forma como o cluster foi dividido está diretamente ligado à renda.O cluster 1 é formado por consumidores de menores renda, de até cerca de 25kUSD, o cluster 2 é formado por consumidores de renda de 25k a 100k, e o último cluster,cluster 3, é composto de consumidores de um intervalo superior ao do cluster 2, entre 50k a 150k. Pode-se observar que a utilização de descontos no grupo tende a zero, diferente do que ocorre nos outros clusters. 

#Análise gráfica 2d - por cluster - income

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~income,color=~cluster,colors=colors,size=3)

```
#Conforme comentado no PCA, parece que quanto maior a despesa com compras, maior é a renda do consumidor. Então o cluster 1 parece ser de clientes com menor poder aquisitivo e o grupo 2 com maior poder aquisitivo. Sendo o grupo 3 um intermédio entre eles.


#Análise gráfica 2d - por cluster - wine

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~wine,color=~cluster,colors=colors,size=3)

```
#Seguindo a lógica do gráfico por renda, temos que o grupo 2 seria os clientes com maior gasto em vinhos, isso já poderia auxiliar a empresa em definir o tipo de produto a ser ofertado através dos meios de comunicação prara cada grupo, um produto mais premium para o  grupo 2, intermediário para o 3 e mais barato ao grupo 1.

#Análise gráfica 3d - por cluster - fruit

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~fruit,color=~cluster,colors=colors,size=3)

```
#Seguindo a lógica do gráfico de vinho, temos que o grupo 2 seria os clientes com maior gasto em frutas, isso já poderia auxiliar a empresa em definir o tipo de produto a ser ofertado através dos meios de comunicação prara cada grupo, um produto mais premium para o  grupo 2, intermediário para o 3 e mais barato ao grupo 1.

#Análise gráfica 3d - por cluster - carne

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~meat,color=~cluster,colors=colors,size=3)

```
#Seguindo a lógica dos outros gráficos, temos que o grupo 2 seria os clientes com maior gasto em carne, isso já poderia auxiliar a empresa em definir o tipo de produto a ser ofertado através dos meios de comunicação prara cada grupo, um produto mais premium para o  grupo 2, intermediário para o 3 e mais barato ao grupo 1. Porém,diferentes dos gráficos de vinho e frutas, parece que o intervalo de gastos com carne é mais estreito que em outros casos, então parece não haver uma variação tão alta como nas outras


#Análise gráfica 3d - por cluster - fish

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~fish,color=~cluster,colors=colors,size=3)

```
#Seguindo a lógica dos outros gráficos, temos que o grupo 2 seria os clientes com maior gasto em peixes, isso já poderia auxiliar a empresa em definir o tipo de produto a ser ofertado através dos meios de comunicação prara cada grupo, um produto mais premium para o  grupo 2, intermediário para o 3 e mais barato ao grupo 1. 


#Análise gráfica 3d - por cluster - gold

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~gold,color=~cluster,colors=colors,size=3)

```
#Um pouco diferente da lógica dos outros gráficos, temos que o grupo 2 e 3 são bem similares nessa categoris, então nesse caso, pode ser que tenhamos a oprtunidade de aumentar o ticket de gast com o cluster 2 através de um comunicação mais direcionada.

#Análise gráfica 3d - por cluster - sweet

```{r GlobalOptions, include=FALSE}

plot_ly(descricao,x=~avg_purchase,y=~sweet,color=~cluster,colors=colors,size=3)

```
#Seguindo a lógica dos outros gráficos, temos que o grupo 2 seria os clientes com maior gasto em doces, isso já poderia auxiliar a empresa em definir o tipo de produto a ser ofertado através dos meios de comunicação prara cada grupo, um produto mais premium para o  grupo 2, intermediário para o 3 e mais barato ao grupo 1. 

#Using DBSCAN

##A presença de ruídos na base pode impactar consideravelmente os resultados obtidos através de análises como PCA e K-means, portanto iremos checar um terceira opção para verificar se coneguimos obter melhores resultados

```{r GlobalOptions, include=FALSE}
# Compute DBSCAN using fpc package

df3<-df %>% 
  select(income,cust_retention_year,days_wo_purchase,wine,fruit,meat,fish,sweet,gold,web_visits_month,age,children,total_expense,total_purchases,avg_purchase,years_education,online_purchases,purchase_discount) %>% 
  scale()
df3 %>% head()

```

#Verificação do melhr eps

```{r GlobalOptions, include=FALSE}
# to plot the eps values
eps_plot = kNNdistplot(df3, k=5)

# to draw an optimum line
eps_plot %>% abline(h = 4, lty = 2)

```

# Plot resultados do DBSCAN 

```{r GlobalOptions, include=FALSE}

set.seed(42)
df_dbs<- df3 %>% 
  fpc:: dbscan(MinPts=40,eps=4)

df_dbs

# Plot DBSCAN results

plot(df_dbs,df3,main="DBSCAN",frame=FALSE)

fviz_cluster(df_dbs, df3, stand = FALSE, frame = FALSE, geom = "point")

```
#Como pode-se observar, como nossa base é muito homogênea e está concentrada numa única região, ao utilizamos o DBSCAN, o número de cluster ideal encontrado é 1. Portanto, essa opção não seria a mais viável no nosso caso atual,pois a informação trazida pelo k-means nos permite aprofundar melhor nossas análises.

#CONCLUSÃO:

#A análise realizada através do PCA e Cluster nos permite segmentar os clientes facilitando o planejamento de atuação em cima do público-alvo: Começando pelo público-alvo, já foi possível perceber que o público se encontra na classe C a E, normalmente a compra desse público é norteado principalmente pelo preço,e a qualidade pode acabar ficando em segundo, isso pode ser um dos motivos pelo qual a disponibilização de desconto tem tanto impacto sobre a variação dos valores.
#Além disso,o consumidor ter filhos parece ser uma variável de grande impacto, então valeria como um segundo passo analisar mais a fundo a relação inversalmente proporcional de gastos e compras com desconto com o número de filhos do consumidor.
#Por último, percebe-se não só pelo PCA, mas como pelo K-means também que  os gastos em cada categoria é diretamente proporcional à classe econômica do consumidor, então é importante que uma comunicação direcionada seja realizada para cada grupo nos veículos de comunicação mais apropiados a fim de termos uma receita otimizada futuramente.


#Por fim,como um dos principais drivers da definição dos cluster seria o gastos médio em compras, ao termos um predição de compras por cliente atrés de modelos preditivos, isso poderia nos ajudar a definir de antemão em qual segmento o cliente se encontraria, e consequemente definiria o melhor plano de ação (taylor made) junto à esse cliente para otimizarmos a receita da empresa e minimizarmos o custo com promoções, já que vimos que não é efetivo do mesmo modo em todos os clusters.

#Predição

```{r GlobalOptions, include=FALSE}

df_pred<- df %>% 
  select(-id,-year_birth,-marital_status,-kidhome,-teenhome,-wine,-fruit,-meat,-fish,-sweet,-gold,-accepted_cmp3,-accepted_cmp4,-accepted_cmp5,-accepted_cmp1,-accepted_cmp2 ,-social_class,-age_class,-total_purchases,-response,-education,-web_purchases,-catalog_purchases,-store_purchases,-education_2,-purchase_discount2,-total_expense
  )

glimpse(df_pred)

```

#Treinamento e teste

```{r GlobalOptions, include=FALSE}
set.seed(42)

split<-initial_split(df_pred,prop=0.8)
split

treinamento<- training(split)
teste<- testing(split)

```

#Crição de uma receita

```{r GlobalOptions, include=FALSE}

receita <- recipe(avg_purchase~ ., data = treinamento)
receita

```

#Normalização

```{r GlobalOptions, include=FALSE}

receita <- receita %>% 
  step_normalize(income,cust_retention_year,days_wo_purchase,
                 deals_purchases,web_visits_month,age,children,online_purchases,years_education,purchase_discount) %>% 
  prep() #Preparação da receita

receita
#receita foi definida, mas ainda não foi aplicada

```

#Bake:aplicação da receita no conjunto de dados

```{r GlobalOptions, include=FALSE}

tr_proc<-bake(receita,new_data = NULL)
tst_proc<-bake(receita,new_data= teste)

```

#Modelo Linear

```{r GlobalOptions, include=FALSE}

lm_fit<-linear_reg(mode="regression",engine = "lm") %>% 
        fit(avg_purchase ~ .,tr_proc)


lm_fit<-linear_reg() %>% 
  set_engine("lm") %>% 
  fit(avg_purchase ~ .,tr_proc)

lm_fit

tidy(lm_fit)

#Previsão

fitted_lm<- lm_fit %>% 
  predict(new_data= tst_proc) %>% 
  mutate(observado= tst_proc$avg_purchase,
         modelo="lm")

head(fitted_lm)

#Observado Vs Predito

fitted_lm %>% 
  ggplot(aes(observado,.pred)) +
  geom_point(size=1,col="purple") +
  labs(x="Observado",y="Predito")

```

#Random Forest

```{r GlobalOptions, include=FALSE}

rf<- rand_forest(mtry=tune(),trees = tune(), min_n = tune(),
                 mode = "regression") %>% 
      set_engine("ranger", importance = "permutation")
  
  
#Ajuste de hiperparâmetros

cv_split<-vfold_cv(treinamento,v=10)

doParallel::registerDoParallel()

rf_grid<-tune_grid(rf,
                   receita,
                   resamples = cv_split,
                   grid = 10,
                   metrics = metric_set(rmse,mae))

autoplot(rf_grid)

rf_grid %>% 
  collect_metrics() %>% 
  head()

#Opção com menor RMSE

best<-rf_grid %>% 
  select_best("rmse")

best

#Modelagem

rf_fit<-finalize_model(rf,parameters = best) %>% 
  fit(avg_purchase~.,tr_proc)

#Predição

fitted_rf<-rf_fit %>% 
  predict(new_data=tst_proc) %>% 
  mutate(observado=tst_proc$avg_purchase,
         modelo='random forest')

fitted_rf

fitted<- fitted_lm %>% 
  bind_rows(fitted_rf) 

fitted %>% 
  group_by(modelo) %>% 
  metrics(truth=observado,estimate=.pred)

```

#Decision Tree

```{r GlobalOptions, include=FALSE}

#Modelo

tree <- decision_tree(tree_depth= tune(), min_n = tune(),
                    mode="regression",engine="rpart")

cv_split <- vfold_cv(treinamento, v = 10)

doParallel::registerDoParallel()

tree_grid <- tune_grid(tree,
                        receita,
                        resamples = cv_split,
                        grid = 10,
                        metrics = metric_set(rmse, mae))

best <- tree_grid %>%
  select_best("rmse")

#Modelagem após a escolha dos hiperparâmetros

tree_fit<-finalize_model(tree,parameters = best) %>%
  fit(avg_purchase~.,tr_proc)

#Predição

fitted_tree<- tree_fit %>% 
  predict(new_data=tst_proc) %>% 
  mutate(observado=tst_proc$avg_purchase,
         modelo="decision tree")

fitted<- bind_rows(fitted,fitted_tree)

```

#Comparação entre modelos ajustados

```{r GlobalOptions, include=FALSE}

fitted %>% 
  group_by(modelo) %>% 
  metrics(truth=observado,estimate=.pred)

```

#Levando-se em consideração o RMSE, o melhor modelo seria a floresta aleatória

```{r GlobalOptions, include=FALSE}

vip(rf_fit)
#variáveis que mais contribuíram foram a renda e compras com desconto

```

